![Picture1](https://user-images.githubusercontent.com/112872366/213405532-a3c62343-a841-4241-a93c-60a1c307a8a6.png)

## Protein Interaction Prediction with Graph Convolutional Neural Networks

This repository contains the code of three graph neural network models that apply graph convolution and various graph pooling methods to generate low-dimensional embeddings of complex protein surfaces modelled as graphs and classifies them into:

- binding to IgG
- not binding to IgG

Using a dataset of protein G subunit B1 (GB1) mutants with experimentally determined binding affinities, we extract a surface patch from the IgG-binding region of all mutants. This patch contains the main interacting amino acid residues that are responsible for the binding interaction in the WT GB1 protein. To retain the full scale of the geometric properties of the surface patches, the patches are modelled as graphs and are used to train a Convolutional Graph Neural Network to create low-dimensional embeddings that are useful to predict the IgG-binding capacity of each mutant. 

***

### Overview Input Data Generation
- Genomic Sequences of the GB1 protein is randomly mutated at four selected sites (39, 40, 41, 54) to generate 23'241 mutants. The WT GB1 protein binds to the constant region of human IgG with high affinity. Experimentally measured binding affinities of the mutants have been generated by Wu et al. (https://elifesciences.org/articles/16965)
- The 3D-structure of the mutants was predicted with ColabFold, an adapted version of AlphaFold2 (https://github.com/sokrypton/ColabFold). 
- Using the resulting PDB files, a molecular surface with geometric and chemical features was computed using dMaSIF (https://github.com/FreyrS/dMaSIF). The output is a point cloud describing a protein surface, where each point has been assigned a vector of 16 learned features.

***

### Code Explanation

#### **extract_patches_from_mutants.py:**
> This file contains code that leverages the data that was generated for all the mutants
>- The PDB-files generated with ColabFold (contains the 3D coordinates of all atoms of the protein)
>- The fitness/affinity values (saved in a dictionary _fitness_dict_short.npy_)
>- The 3D-coordinates of the points in the computed surface point cloud (_predcoords_)
>- The features assigned to each point in the surface point cloud (_predfeatures_)
>
>This data is used to extract a surface patch from the binding region of GB1 and modell this patch as a graph. For each mutant, the following steps are performed:
>1. Import the above described data of the mutant
>2. Parse the PDB file of the mutant with BioPython, locate the IgG-binding region (see f_parse_pdb.py)
>3. Extract a circular surface patch with fixed geodesic radius from this region and model it as a graph compatible with the PyTorch geometric library, i.e. with a feature matrix x, an edge index and edge weights correponding to the geodesic distance between the points the edge is connecting (see the function _extract_surface_patch_GCN_ in f_extract_surface_patch.py)
>4. Save it as an instance of the custom _GraphPatch_ class together with the corresponding fitness/affinity value (see c_GraphPatch.py)

#### f_extract_surface_patch.py
> This file contains a set of functions that take the surface point cloud with its features and coordinates, the center for patch extraction and the desired geodesic radius and returns the a circular patch of the given geodesic radius drawn around the given patch center and modelled as a graph with edge index, adjacency matrix, edge_weights and features. The following steps are performed:
> 1. All points that have a Euclidean distance greater than the given radius are removed from the pointcloud
> 2. From the remaining points, a simplified graph is generated by connecting each point with its 10 nearest neighbors and calculating the geodesic distance between the connected points. All connections are saved in a dictionary together with their geodesic distances. 
> 3. For each point, Djikstra algorithm is used to compute the geodesic distance to the center. Points that are more than the desired radius away from the center are removed. 
> 4. The connections between the remaining points are saved in an adjacency matrix, the softmin(geodesic distances) in a weight matrix, the features in a feature matrix and the coordinates in a pos matrix. 

#### f_parse_pdb.py
>This function uses the PDBParser from BioPython to import a PDB file and extract the residues, the atom types and atom coordinates of the protein. The residues with their atoms are saved in a double dictionary, the atom coords are saved in a numpy array.'''

#### c_GraphPatch.py
>Definition of a custom python Class designed to store all relevant data to describe an extracted surface patch graph, including coordinates of the graph nodes (pos), the features (x), the adjacency information (edge_index), the edge weights (edge_attr) and the fitness (y) and the name of the mutant'''

#### f_helper_functions.py
>Contains small functions that are used throughout the code, e.g. 
>- _normalize_featurewise_ is used to normalize feature matrices between -1 and 1 in a column-wise manner, so that each feature is normalized independently from the other features in the dataset
>- _save_object_ and _load_object_ are used to save and load instances of the _GraphPatch_ class as pickle files. 

#### f_extract_surface_patch_padded.py & extract_patches_from_mutants_padded.py
> These files are identical to the unpadded version described above, except that they contain an additional code for padding graphs. All graphs were padded until they reached the number of nodes of the largest graph in the dataset. If a graph was smaller than the largest graph in the dataset, additional points were introduced between two randomly selected connected points of the graph until the graph reached the desired size. The coordinates and the surface normal of the new point were computed as a weighted average from its nearest neighbors. The features of the new point were computed using the knn interpolate function of the PyTorch Geometric library. 






